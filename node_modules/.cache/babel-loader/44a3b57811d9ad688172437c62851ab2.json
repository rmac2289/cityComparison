{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _response = _interopRequireDefault(require(\"./response\"));\n\nvar _util = _interopRequireDefault(require(\"util\"));\n\nvar _errors = require(\"./errors\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n/**\n * Listen to changes in the HTTP request and build Response/ResponseError\n * objects accordingly.\n *\n * @param {Request} request the request object used to make the call\n * @param {EventEmitter} emitter a Node event emitter\n * @param {Client} client the client instance to log results to\n * @protected\n */\n\n\nvar Listener = /*#__PURE__*/function () {\n  function Listener(request, emitter, client) {\n    _classCallCheck(this, Listener);\n\n    this.request = request;\n    this.emitter = emitter;\n    this.client = client;\n  } // PROTECTED\n\n  /**\n   * Listens to various events on the http_response object, listening for data,\n   * connections closing for bad reasons, and the end of the response.\n   *\n   * Used by the Client when making an API call.\n   *\n   * @param  {Object} http_response a Node http response object\n   * @protected\n   */\n\n\n  _createClass(Listener, [{\n    key: \"onResponse\",\n    value: function onResponse(http_response) {\n      var response = new _response[\"default\"](http_response, this.request);\n      http_response.on('data', response.addChunk.bind(response));\n      http_response.on('end', this.onEnd(response).bind(this));\n      http_response.on('close', this.onNetworkError(response).bind(this));\n      http_response.on('error', this.onNetworkError(response).bind(this));\n    }\n    /**\n     * Listens to a network error when making an API call.\n     *\n     * Used by the Client when making an API call.\n     *\n     * @param  {Object} http_response a Node http response object\n     * @protected\n     */\n\n  }, {\n    key: \"onError\",\n    value: function onError(http_response) {\n      var response = new _response[\"default\"](http_response, this.request);\n      this.onNetworkError(response)();\n    } // PRIVATE\n\n    /**\n     * When the connection ends, check if the response can be parsed or not and\n     * act accordingly.\n     *\n     * @param  {Response} response\n     */\n\n  }, {\n    key: \"onEnd\",\n    value: function onEnd(response) {\n      var _this = this;\n\n      return function () {\n        response.parse();\n\n        if (response.success()) {\n          _this.onSuccess(response);\n        } else {\n          _this.onFail(response);\n        }\n      };\n    }\n    /**\n     * When the response was successful, resolve the promise and return the\n     * response object\n     *\n     * @param  {Response} response\n     */\n\n  }, {\n    key: \"onSuccess\",\n    value: function onSuccess(response) {\n      this.log(response);\n      this.emitter.emit('resolve', response);\n    }\n    /**\n     * When the connection was not successful, determine the reason and resolve\n     * the promise accordingly.\n     *\n     * @param  {Response} response\n     */\n\n  }, {\n    key: \"onFail\",\n    value: function onFail(response) {\n      var Error = this.errorFor(response);\n      var error = new Error(response);\n      this.log(response, error);\n      this.emitter.emit('reject', error);\n    }\n    /**\n     * Find the right error for the given response.\n     *\n     * @param {Response} reponse\n     * @returns {ResponseError}\n     */\n\n  }, {\n    key: \"errorFor\",\n    value: function errorFor(_ref) {\n      var statusCode = _ref.statusCode,\n          parsed = _ref.parsed;\n      var error = null;\n\n      if (statusCode >= 500) {\n        error = _errors.ServerError;\n      } else if (statusCode == 401) {\n        error = _errors.AuthenticationError;\n      } else if (statusCode == 404) {\n        error = _errors.NotFoundError;\n      } else if (statusCode >= 400) {\n        error = _errors.ClientError;\n      } else if (!parsed) {\n        error = _errors.ParserError;\n      } else {\n        error = _errors.UnknownError;\n      }\n\n      return error;\n    }\n    /**\n     * When the connection ran into a network error, reject the promise with a\n     * NetworkError.\n     *\n     * @param  {Response} response\n     */\n\n  }, {\n    key: \"onNetworkError\",\n    value: function onNetworkError(response) {\n      var _this2 = this;\n\n      return function () {\n        response.parse();\n        var error = new _errors.NetworkError(response);\n\n        _this2.log(response, error);\n\n        _this2.emitter.emit('reject', error);\n      };\n    }\n    /**\n     * Logs the response, when in debug mode\n     *\n     * @param  {Response} response the response object to log\n     * @private\n     */\n\n  }, {\n    key: \"log\",\n    value: function log(response, error) {\n      if (this.client.debug()) {\n        /* istanbul ignore next */\n        this.client.logger.log(_util[\"default\"].inspect(response, false, null));\n      }\n\n      if (!this.client.debug() && this.client.warn() && error) {\n        /* istanbul ignore next */\n        this.client.logger.log('Amadeus', error.code, error.description);\n      }\n    }\n  }]);\n\n  return Listener;\n}();\n\nvar _default = Listener;\nexports[\"default\"] = _default;\nmodule.exports = exports[\"default\"];","map":{"version":3,"sources":["../../../src/amadeus/client/listener.js"],"names":["Listener","http_response","response","Response","Error","error","statusCode","parsed","ServerError","AuthenticationError","NotFoundError","ClientError","ParserError","UnknownError","NetworkError","util"],"mappings":"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","sourcesContent":["import Response from './response';\nimport util     from 'util';\n\nimport {\n  ServerError,\n  NotFoundError,\n  ClientError,\n  ParserError,\n  UnknownError,\n  NetworkError,\n  AuthenticationError\n} from './errors';\n\n\n/**\n * Listen to changes in the HTTP request and build Response/ResponseError\n * objects accordingly.\n *\n * @param {Request} request the request object used to make the call\n * @param {EventEmitter} emitter a Node event emitter\n * @param {Client} client the client instance to log results to\n * @protected\n */\nclass Listener {\n  constructor(request, emitter, client) {\n    this.request = request;\n    this.emitter = emitter;\n    this.client  = client;\n  }\n\n  // PROTECTED\n\n\n  /**\n   * Listens to various events on the http_response object, listening for data,\n   * connections closing for bad reasons, and the end of the response.\n   *\n   * Used by the Client when making an API call.\n   *\n   * @param  {Object} http_response a Node http response object\n   * @protected\n   */\n  onResponse(http_response) {\n    let response = new Response(http_response, this.request);\n\n    http_response.on('data',  response.addChunk.bind(response));\n    http_response.on('end',   this.onEnd(response).bind(this));\n    http_response.on('close', this.onNetworkError(response).bind(this));\n    http_response.on('error', this.onNetworkError(response).bind(this));\n  }\n\n  /**\n   * Listens to a network error when making an API call.\n   *\n   * Used by the Client when making an API call.\n   *\n   * @param  {Object} http_response a Node http response object\n   * @protected\n   */\n\n  onError(http_response) {\n    let response = new Response(http_response, this.request);\n    this.onNetworkError(response)();\n  }\n\n  // PRIVATE\n\n\n  /**\n   * When the connection ends, check if the response can be parsed or not and\n   * act accordingly.\n   *\n   * @param  {Response} response\n   */\n  onEnd(response) {\n    return () => {\n      response.parse();\n      if (response.success()) { this.onSuccess(response); }\n      else { this.onFail(response);  }\n    };\n  }\n\n  /**\n   * When the response was successful, resolve the promise and return the\n   * response object\n   *\n   * @param  {Response} response\n   */\n  onSuccess(response) {\n    this.log(response);\n    this.emitter.emit('resolve', response);\n  }\n\n  /**\n   * When the connection was not successful, determine the reason and resolve\n   * the promise accordingly.\n   *\n   * @param  {Response} response\n   */\n  onFail(response) {\n    let Error = this.errorFor(response);\n    let error = new Error(response);\n    this.log(response, error);\n    this.emitter.emit('reject', error);\n  }\n\n\n  /**\n   * Find the right error for the given response.\n   *\n   * @param {Response} reponse\n   * @returns {ResponseError}\n   */\n  errorFor({statusCode, parsed}) {\n    let error = null;\n    if (statusCode >= 500) { error = ServerError; }\n    else if (statusCode == 401) { error = AuthenticationError; }\n    else if (statusCode == 404) { error = NotFoundError; }\n    else if (statusCode >= 400) { error = ClientError; }\n    else if (!parsed) { error = ParserError; }\n    else { error = UnknownError; }\n    return error;\n  }\n\n  /**\n   * When the connection ran into a network error, reject the promise with a\n   * NetworkError.\n   *\n   * @param  {Response} response\n   */\n  onNetworkError(response) {\n    return () => {\n      response.parse();\n      let error = new NetworkError(response);\n      this.log(response, error);\n      this.emitter.emit('reject', error);\n    };\n  }\n\n  /**\n   * Logs the response, when in debug mode\n   *\n   * @param  {Response} response the response object to log\n   * @private\n   */\n  log(response, error) {\n    if (this.client.debug()) {\n      /* istanbul ignore next */\n      this.client.logger.log(util.inspect(response, false, null));\n    }\n    if (!this.client.debug() && this.client.warn() && error) {\n      /* istanbul ignore next */\n      this.client.logger.log('Amadeus', error.code, error.description);\n    }\n  }\n}\n\nexport default Listener;\n"]},"metadata":{},"sourceType":"script"}