{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _events = _interopRequireDefault(require(\"events\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n} // The number of seconds before the token expires, when\n// we will already try to refresh it\n\n\nvar TOKEN_BUFFER = 10;\n/**\n  * A helper library to create and maintain the OAuth2 AccessTokens between\n  * requests. Keeps track of the expiry time and automatically tries to fetch\n  * a new token if needed.\n  *\n  * @property {string} accessToken the cached current access token (bearer)\n  * @property {number} expiresAt the aproximate time this token expires at\n  * @protected\n  */\n\nvar AccessToken = /*#__PURE__*/function () {\n  function AccessToken() {\n    _classCallCheck(this, AccessToken);\n\n    this.accessToken;\n    this.expiresAt;\n  } // PROTECTED\n\n  /**\n   * Fetches or returns a cached bearer token. Used by the Client to get a\n   * token before making an API call.\n   *\n   * @param  {Client} client the Amadeus Client to make an API call with\n   * @return {Promise.<Response,ResponseError>} a Bluebird Promise\n   * @protected\n   */\n\n\n  _createClass(AccessToken, [{\n    key: \"bearerToken\",\n    value: function bearerToken(client) {\n      var emitter = new _events[\"default\"]();\n      var promise = this.promise(emitter);\n      this.emitOrLoadAccessToken(client, emitter);\n      return promise;\n    } // PRIVATE\n\n    /**\n     * Builds a Bluebird promise to be returned to the API user\n     *\n     * @param  {type} emitter the EventEmitter used to notify the Promise of\n     * @return {Promise} a Bluebird promise\n     * @private\n     */\n\n  }, {\n    key: \"promise\",\n    value: function promise(emitter) {\n      return new Promise(function (resolve, reject) {\n        emitter.on('resolve', function (response) {\n          return resolve(response);\n        });\n        emitter.on('reject', function (error) {\n          return reject(error);\n        });\n      });\n    }\n    /**\n     * Checks if the token needs a refresh, if not emits the cached token,\n     * otherwise tries to load a new access token\n     *\n     * @param  {Client} client the Amadeus Client to make an API call with\n     * @param  {type} emitter the EventEmitter used to emit the token\n     * @private\n     */\n\n  }, {\n    key: \"emitOrLoadAccessToken\",\n    value: function emitOrLoadAccessToken(client, emitter) {\n      if (this.needsLoadOrRefresh()) {\n        this.loadAccessToken(client, emitter);\n      } else {\n        emitter.emit('resolve', this.accessToken);\n      }\n    }\n    /**\n     * Checks if the token needs a refresh or first load\n     *\n     * @return {boolean} wether the token needs a refresh\n     * @private\n     */\n\n  }, {\n    key: \"needsLoadOrRefresh\",\n    value: function needsLoadOrRefresh() {\n      if (!this.accessToken) {\n        return true;\n      } else if (Date.now() + TOKEN_BUFFER > this.expiresAt) {\n        return true;\n      } else {\n        return false;\n      }\n    }\n    /**\n     * Loads the access token using the client, emits the token when it's loaded\n     *\n     * @param  {Client} client the Amadeus Client to make an API call with\n     * @param  {type} emitter the EventEmitter used to emit the token\n     * @private\n     */\n\n  }, {\n    key: \"loadAccessToken\",\n    value: function loadAccessToken(client, emitter) {\n      var _this = this;\n\n      client.unauthenticatedRequest('POST', '/v1/security/oauth2/token', {\n        'grant_type': 'client_credentials',\n        'client_id': client.clientId,\n        'client_secret': client.clientSecret\n      }).then(function (response) {\n        _this.storeAccessToken(response);\n\n        _this.emitOrLoadAccessToken(client, emitter);\n      })[\"catch\"](function (error) {\n        emitter.emit('reject', error);\n      });\n    }\n    /**\n     * Stores a loaded access token, calculating the expiry date\n     *\n     * @param  {Response} response the response object received from the client\n     * @private\n     */\n\n  }, {\n    key: \"storeAccessToken\",\n    value: function storeAccessToken(response) {\n      this.accessToken = response.result['access_token'];\n      this.expiresAt = Date.now() + response.result['expires_in'] * 1000;\n    }\n  }]);\n\n  return AccessToken;\n}();\n\nvar _default = AccessToken;\nexports[\"default\"] = _default;\nmodule.exports = exports[\"default\"];","map":{"version":3,"sources":["../../../src/amadeus/client/access_token.js"],"names":["TOKEN_BUFFER","AccessToken","client","emitter","EventEmitter","promise","resolve","reject","Date","clientSecret","response"],"mappings":";;;;;;;AAAA,IAAA,OAAA,GAAA,sBAAA,CAAA,OAAA,CAAA,QAAA,CAAA,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAEA;AACA;;;AACA,IAAMA,YAAY,GAAlB,EAAA;AAEA;;;;;;;;;;IASMC,W;AACJ,WAAA,WAAA,GAAc;AAAA,IAAA,eAAA,CAAA,IAAA,EAAA,WAAA,CAAA;;AACZ,SAAA,WAAA;AACA,SAAA,SAAA;IAGF;;AAEA;;;;;;;;;;;;gCAQYC,M,EAAQ;AAClB,UAAIC,OAAO,GAAG,IAAIC,OAAAA,CAAlB,SAAkBA,CAAJ,EAAd;AACA,UAAIC,OAAO,GAAG,KAAA,OAAA,CAAd,OAAc,CAAd;AACA,WAAA,qBAAA,CAAA,MAAA,EAAA,OAAA;AACA,aAAA,OAAA;MAGF;;AAEA;;;;;;;;;;4BAOQF,O,EAAS;AACf,aAAO,IAAA,OAAA,CAAY,UAAA,OAAA,EAAA,MAAA,EAAqB;AACtCA,QAAAA,OAAO,CAAPA,EAAAA,CAAAA,SAAAA,EAAsB,UAAA,QAAA,EAAQ;AAAA,iBAAIG,OAAO,CAAX,QAAW,CAAX;AAA9BH,SAAAA;AACAA,QAAAA,OAAO,CAAPA,EAAAA,CAAAA,QAAAA,EAAqB,UAAA,KAAA,EAAK;AAAA,iBAAII,MAAM,CAAV,KAAU,CAAV;AAA1BJ,SAAAA;AAFF,OAAO,CAAP;AAID;AAGD;;;;;;;;;;;0CAQsBD,M,EAAQC,O,EAAS;AACrC,UAAI,KAAJ,kBAAI,EAAJ,EAA+B;AAAE,aAAA,eAAA,CAAA,MAAA,EAAA,OAAA;AAAjC,OAAA,MACK;AAAEA,QAAAA,OAAO,CAAPA,IAAAA,CAAAA,SAAAA,EAAwB,KAAxBA,WAAAA;AAA4C;AACpD;AAED;;;;;;;;;yCAMqB;AACnB,UAAI,CAAC,KAAL,WAAA,EAAuB;AAAE,eAAA,IAAA;AAAzB,OAAA,MACK,IAAKK,IAAI,CAAJA,GAAAA,KAAD,YAACA,GAA6B,KAAlC,SAAA,EAAkD;AAAE,eAAA,IAAA;AAApD,OAAA,MACA;AAAE,eAAA,KAAA;AAAe;AACvB;AAGD;;;;;;;;;;oCAOgBN,M,EAAQC,O,EAAS;AAAA,UAAA,KAAA,GAAA,IAAA;;AAC/BD,MAAAA,MAAM,CAANA,sBAAAA,CAAAA,MAAAA,EAAAA,2BAAAA,EAAmE;AACjE,sBADiE,oBAAA;AAEjE,qBAAcA,MAAM,CAF6C,QAAA;AAGjE,yBAAkBA,MAAM,CAACO;AAHwC,OAAnEP,EAAAA,IAAAA,CAIQ,UAAA,QAAA,EAAc;AACpB,QAAA,KAAI,CAAJ,gBAAA,CAAA,QAAA;;AACA,QAAA,KAAI,CAAJ,qBAAA,CAAA,MAAA,EAAA,OAAA;AANFA,OAAAA,EAAAA,OAAAA,EAOS,UAAA,KAAA,EAAW;AAClBC,QAAAA,OAAO,CAAPA,IAAAA,CAAAA,QAAAA,EAAAA,KAAAA;AARFD,OAAAA;AAUD;AAED;;;;;;;;;qCAMiBQ,Q,EAAU;AACzB,WAAA,WAAA,GAAmBA,QAAQ,CAARA,MAAAA,CAAnB,cAAmBA,CAAnB;AACA,WAAA,SAAA,GAAiBF,IAAI,CAAJA,GAAAA,KAAcE,QAAQ,CAARA,MAAAA,CAAAA,YAAAA,IAA/B,IAAA;AACD;;;;;;eAGYT,W","sourcesContent":["import EventEmitter from 'events';\n\n// The number of seconds before the token expires, when\n// we will already try to refresh it\nconst TOKEN_BUFFER = 10;\n\n/**\n  * A helper library to create and maintain the OAuth2 AccessTokens between\n  * requests. Keeps track of the expiry time and automatically tries to fetch\n  * a new token if needed.\n  *\n  * @property {string} accessToken the cached current access token (bearer)\n  * @property {number} expiresAt the aproximate time this token expires at\n  * @protected\n  */\nclass AccessToken {\n  constructor() {\n    this.accessToken;\n    this.expiresAt;\n  }\n\n  // PROTECTED\n\n  /**\n   * Fetches or returns a cached bearer token. Used by the Client to get a\n   * token before making an API call.\n   *\n   * @param  {Client} client the Amadeus Client to make an API call with\n   * @return {Promise.<Response,ResponseError>} a Bluebird Promise\n   * @protected\n   */\n  bearerToken(client) {\n    let emitter = new EventEmitter();\n    let promise = this.promise(emitter);\n    this.emitOrLoadAccessToken(client, emitter);\n    return promise;\n  }\n\n  // PRIVATE\n\n  /**\n   * Builds a Bluebird promise to be returned to the API user\n   *\n   * @param  {type} emitter the EventEmitter used to notify the Promise of\n   * @return {Promise} a Bluebird promise\n   * @private\n   */\n  promise(emitter) {\n    return new Promise((resolve, reject) => {\n      emitter.on('resolve', response => resolve(response));\n      emitter.on('reject', error => reject(error));\n    });\n  }\n\n\n  /**\n   * Checks if the token needs a refresh, if not emits the cached token,\n   * otherwise tries to load a new access token\n   *\n   * @param  {Client} client the Amadeus Client to make an API call with\n   * @param  {type} emitter the EventEmitter used to emit the token\n   * @private\n   */\n  emitOrLoadAccessToken(client, emitter) {\n    if (this.needsLoadOrRefresh()) { this.loadAccessToken(client, emitter); }\n    else { emitter.emit('resolve', this.accessToken); }\n  }\n\n  /**\n   * Checks if the token needs a refresh or first load\n   *\n   * @return {boolean} wether the token needs a refresh\n   * @private\n   */\n  needsLoadOrRefresh() {\n    if (!this.accessToken) { return true; }\n    else if ((Date.now() + TOKEN_BUFFER) > this.expiresAt) { return true; }\n    else { return false; }\n  }\n\n\n  /**\n   * Loads the access token using the client, emits the token when it's loaded\n   *\n   * @param  {Client} client the Amadeus Client to make an API call with\n   * @param  {type} emitter the EventEmitter used to emit the token\n   * @private\n   */\n  loadAccessToken(client, emitter) {\n    client.unauthenticatedRequest('POST', '/v1/security/oauth2/token', {\n      'grant_type' : 'client_credentials',\n      'client_id' : client.clientId,\n      'client_secret' : client.clientSecret\n    }).then((response) => {\n      this.storeAccessToken(response);\n      this.emitOrLoadAccessToken(client, emitter);\n    }).catch((error) => {\n      emitter.emit('reject', error);\n    });\n  }\n\n  /**\n   * Stores a loaded access token, calculating the expiry date\n   *\n   * @param  {Response} response the response object received from the client\n   * @private\n   */\n  storeAccessToken(response) {\n    this.accessToken = response.result['access_token'];\n    this.expiresAt = Date.now() + (response.result['expires_in'] * 1000);\n  }\n}\n\nexport default AccessToken;\n"]},"metadata":{},"sourceType":"script"}